/// DO NOT EDIT - This file was auto-generated by CleanseGen/main.swift
extension PropertyInjectorBindingBuilderProtocol {

/// 1-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get())
}, file: file, line: line, function: function)
}
/// 2-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get())
}, file: file, line: line, function: function)
}
/// 3-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get())
}, file: file, line: line, function: function)
}
/// 4-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get())
}, file: file, line: line, function: function)
}
/// 5-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get())
}, file: file, line: line, function: function)
}
/// 6-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get())
}, file: file, line: line, function: function)
}
/// 7-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get())
}, file: file, line: line, function: function)
}
/// 8-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get())
}, file: file, line: line, function: function)
}
/// 9-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get())
}, file: file, line: line, function: function)
}
/// 10-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get())
}, file: file, line: line, function: function)
}
/// 11-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get())
}, file: file, line: line, function: function)
}
/// 12-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get())
}, file: file, line: line, function: function)
}
/// 13-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get())
}, file: file, line: line, function: function)
}
/// 14-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get())
}, file: file, line: line, function: function)
}
/// 15-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get())
}, file: file, line: line, function: function)
}
/// 16-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get())
}, file: file, line: line, function: function)
}
/// 17-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get())
}, file: file, line: line, function: function)
}
/// 18-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get())
}, file: file, line: line, function: function)
}
/// 19-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get())
}, file: file, line: line, function: function)
}
/// 20-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get())
}, file: file, line: line, function: function)
}
/// 21-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get())
}, file: file, line: line, function: function)
}
/// 22-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get())
}, file: file, line: line, function: function)
}
/// 23-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get())
}, file: file, line: line, function: function)
}
/// 24-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get())
}, file: file, line: line, function: function)
}
/// 25-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get())
}, file: file, line: line, function: function)
}
/// 26-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get())
}, file: file, line: line, function: function)
}
/// 27-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get())
}, file: file, line: line, function: function)
}
/// 28-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider28 = binder.provider(P_28.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get(),
        provider28.get())
}, file: file, line: line, function: function)
}
/// 29-arity `to(injector:(Element)->(Element, arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// with `binder.bindPropertyInjector(`class`: Foo.self).to(injector: Foo.injectProperties)`
/// - example: ```binder.bindPropertyInjector(Foo.self).to { $0.foo = $1 }```
/// - parameter factory: Takes arguments required to construct `Element` passed to the `bind()` function
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28, P_29>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element) -> (P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28, P_29) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider28 = binder.provider(P_28.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider29 = binder.provider(P_29.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector($0)(

        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get(),
        provider28.get(),
        provider29.get())
}, file: file, line: line, function: function)
}
/// 1-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get())
}, file: file, line: line, function: function)
}
/// 2-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get())
}, file: file, line: line, function: function)
}
/// 3-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get())
}, file: file, line: line, function: function)
}
/// 4-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get())
}, file: file, line: line, function: function)
}
/// 5-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get())
}, file: file, line: line, function: function)
}
/// 6-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get())
}, file: file, line: line, function: function)
}
/// 7-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get())
}, file: file, line: line, function: function)
}
/// 8-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get())
}, file: file, line: line, function: function)
}
/// 9-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get())
}, file: file, line: line, function: function)
}
/// 10-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get())
}, file: file, line: line, function: function)
}
/// 11-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get())
}, file: file, line: line, function: function)
}
/// 12-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get())
}, file: file, line: line, function: function)
}
/// 13-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get())
}, file: file, line: line, function: function)
}
/// 14-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get())
}, file: file, line: line, function: function)
}
/// 15-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get())
}, file: file, line: line, function: function)
}
/// 16-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get())
}, file: file, line: line, function: function)
}
/// 17-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get())
}, file: file, line: line, function: function)
}
/// 18-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get())
}, file: file, line: line, function: function)
}
/// 19-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get())
}, file: file, line: line, function: function)
}
/// 20-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get())
}, file: file, line: line, function: function)
}
/// 21-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get())
}, file: file, line: line, function: function)
}
/// 22-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get())
}, file: file, line: line, function: function)
}
/// 23-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get())
}, file: file, line: line, function: function)
}
/// 24-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get())
}, file: file, line: line, function: function)
}
/// 25-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get())
}, file: file, line: line, function: function)
}
/// 26-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get())
}, file: file, line: line, function: function)
}
/// 27-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get())
}, file: file, line: line, function: function)
}
/// 28-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider28 = binder.provider(P_28.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get(),
        provider28.get())
}, file: file, line: line, function: function)
}
/// 29-arity `to(injector injector:(Element)->(arg1, arg2, ...) -> Void` function.
/// This variant is intended for to pass unbound instance methods too. For example, if `Foo` had an instance method `injectProperties`.
/// - example: ```binder.bindPropertyInjector(Foo.self).to(injector: Foo.injectProperties)```
/// - parameter injector: Takes `Element` and the resulting closure should take parameters to inject properties into e
///
/// - Note: This method was generated by `main.swift`
@discardableResult public func to<P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28, P_29>(file: StaticString=#file, line: Int=#line, function: StaticString=#function, injector: @escaping (Element,P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14, P_15, P_16, P_17, P_18, P_19, P_20, P_21, P_22, P_23, P_24, P_25, P_26, P_27, P_28, P_29) -> Void) -> BindingReceipt<PropertyInjector<Element>> {
let binder = self.binder
    let provider1 = binder.provider(P_1.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider2 = binder.provider(P_2.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider3 = binder.provider(P_3.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider4 = binder.provider(P_4.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider5 = binder.provider(P_5.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider6 = binder.provider(P_6.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider7 = binder.provider(P_7.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider8 = binder.provider(P_8.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider9 = binder.provider(P_9.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider10 = binder.provider(P_10.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider11 = binder.provider(P_11.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider12 = binder.provider(P_12.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider13 = binder.provider(P_13.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider14 = binder.provider(P_14.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider15 = binder.provider(P_15.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider16 = binder.provider(P_16.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider17 = binder.provider(P_17.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider18 = binder.provider(P_18.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider19 = binder.provider(P_19.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider20 = binder.provider(P_20.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider21 = binder.provider(P_21.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider22 = binder.provider(P_22.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider23 = binder.provider(P_23.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider24 = binder.provider(P_24.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider25 = binder.provider(P_25.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider26 = binder.provider(P_26.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider27 = binder.provider(P_27.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider28 = binder.provider(P_28.self, file: file, line: line, function: function, providerRequiredFor: Element.self)
    let provider29 = binder.provider(P_29.self, file: file, line: line, function: function, providerRequiredFor: Element.self)

    return innerTo(propertyInjector: {
injector(
$0,
        provider1.get(),
        provider2.get(),
        provider3.get(),
        provider4.get(),
        provider5.get(),
        provider6.get(),
        provider7.get(),
        provider8.get(),
        provider9.get(),
        provider10.get(),
        provider11.get(),
        provider12.get(),
        provider13.get(),
        provider14.get(),
        provider15.get(),
        provider16.get(),
        provider17.get(),
        provider18.get(),
        provider19.get(),
        provider20.get(),
        provider21.get(),
        provider22.get(),
        provider23.get(),
        provider24.get(),
        provider25.get(),
        provider26.get(),
        provider27.get(),
        provider28.get(),
        provider29.get())
}, file: file, line: line, function: function)
}
}

